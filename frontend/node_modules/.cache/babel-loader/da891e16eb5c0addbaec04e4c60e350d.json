{"ast":null,"code":"export function getFirstItem(array) {\n  return array != null && array.length ? array[0] : undefined;\n}\nexport function getLastItem(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\nexport function getPrevItem(index, array, loop) {\n  if (loop === void 0) {\n    loop = true;\n  }\n\n  var prevIndex = getPrevIndex(index, array.length, loop);\n  return array[prevIndex];\n}\nexport function getNextItem(index, array, loop) {\n  if (loop === void 0) {\n    loop = true;\n  }\n\n  var nextIndex = getNextIndex(index, array.length, 1, loop);\n  return array[nextIndex];\n}\nexport function removeIndex(array, index) {\n  return array.filter((_, idx) => idx !== index);\n}\nexport function addItem(array, item) {\n  return [...array, item];\n}\nexport function removeItem(array, item) {\n  return array.filter(eachItem => eachItem !== item);\n}\n/**\n * Get the next index based on the current index and step.\n *\n * @param currentIndex the current index\n * @param length the total length or count of items\n * @param step the number of steps\n * @param loop whether to circle back once `currentIndex` is at the start/end\n */\n\nexport function getNextIndex(currentIndex, length, step, loop) {\n  if (step === void 0) {\n    step = 1;\n  }\n\n  if (loop === void 0) {\n    loop = true;\n  }\n\n  var lastIndex = length - 1;\n\n  if (currentIndex === -1) {\n    return step > 0 ? 0 : lastIndex;\n  }\n\n  var nextIndex = currentIndex + step;\n\n  if (nextIndex < 0) {\n    return loop ? lastIndex : 0;\n  }\n\n  if (nextIndex >= length) {\n    if (loop) return 0;\n    return currentIndex > length ? length : currentIndex;\n  }\n\n  return nextIndex;\n}\n/**\n * Get's the previous index based on the current index.\n * Mostly used for keyboard navigation.\n *\n * @param index - the current index\n * @param count - the length or total count of items in the array\n * @param loop - whether we should circle back to the\n * first/last once `currentIndex` is at the start/end\n */\n\nexport function getPrevIndex(currentIndex, count, loop) {\n  if (loop === void 0) {\n    loop = true;\n  }\n\n  return getNextIndex(currentIndex, count, -1, loop);\n}\n/**\n * Converts an array into smaller chunks or groups.\n *\n * @param array the array to chunk into group\n * @param size the length of each chunk\n */\n\nexport function chunk(array, size) {\n  return array.reduce((rows, currentValue, index) => {\n    if (index % size === 0) {\n      rows.push([currentValue]);\n    } else {\n      rows[rows.length - 1].push(currentValue);\n    }\n\n    return rows;\n  }, []);\n}\n/**\n * Gets the next item based on a search string\n *\n * @param items array of items\n * @param searchString the search string\n * @param itemToString resolves an item to string\n * @param currentItem the current selected item\n */\n\nexport function getNextItemFromSearch(items, searchString, itemToString, currentItem) {\n  if (searchString == null) {\n    return currentItem;\n  } // If current item doesn't exist, find the item that matches the search string\n\n\n  if (!currentItem) {\n    var foundItem = items.find(item => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()));\n    return foundItem;\n  } // Filter items for ones that match the search string (case insensitive)\n\n\n  var matchingItems = items.filter(item => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase())); // If there's a match, let's get the next item to select\n\n  if (matchingItems.length > 0) {\n    var nextIndex; // If the currentItem is in the available items, we move to the next available option\n\n    if (matchingItems.includes(currentItem)) {\n      var currentIndex = matchingItems.indexOf(currentItem);\n      nextIndex = currentIndex + 1;\n\n      if (nextIndex === matchingItems.length) {\n        nextIndex = 0;\n      }\n\n      return matchingItems[nextIndex];\n    } // Else, we pick the first item in the available items\n\n\n    nextIndex = items.indexOf(matchingItems[0]);\n    return items[nextIndex];\n  } // a decent fallback to the currentItem\n\n\n  return currentItem;\n}\n/**\n * since breakpoints are defined as custom properties on an array, you may\n * `Object.keys(theme.breakpoints)` to retrieve both regular numeric indices\n * and custom breakpoints as string.\n *\n * This function returns true given a custom array property.\n */\n\nexport var isCustomBreakpoint = maybeBreakpoint => Number.isNaN(Number(maybeBreakpoint));","map":{"version":3,"sources":["../../src/array.ts"],"names":["array","length","loop","prevIndex","getPrevIndex","nextIndex","getNextIndex","idx","eachItem","step","lastIndex","currentIndex","index","rows","searchString","foundItem","items","item","itemToString","matchingItems","isCustomBreakpoint","maybeBreakpoint","Number"],"mappings":"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","sourcesContent":["export function getFirstItem<T>(array: T[]) {\n  return array != null && array.length ? array[0] : undefined\n}\n\nexport function getLastItem<T>(array: T[]) {\n  const length = array == null ? 0 : array.length\n  return length ? array[length - 1] : undefined\n}\n\nexport function getPrevItem<T>(index: number, array: T[], loop = true) {\n  const prevIndex = getPrevIndex(index, array.length, loop)\n  return array[prevIndex]\n}\n\nexport function getNextItem<T>(index: number, array: T[], loop = true) {\n  const nextIndex = getNextIndex(index, array.length, 1, loop)\n  return array[nextIndex]\n}\n\nexport function removeIndex<T>(array: T[], index: number) {\n  return array.filter((_, idx) => idx !== index)\n}\n\nexport function addItem<T>(array: T[], item: T) {\n  return [...array, item]\n}\n\nexport function removeItem<T>(array: T[], item: T) {\n  return array.filter((eachItem) => eachItem !== item)\n}\n\n/**\n * Get the next index based on the current index and step.\n *\n * @param currentIndex the current index\n * @param length the total length or count of items\n * @param step the number of steps\n * @param loop whether to circle back once `currentIndex` is at the start/end\n */\nexport function getNextIndex(\n  currentIndex: number,\n  length: number,\n  step = 1,\n  loop = true,\n) {\n  const lastIndex = length - 1\n\n  if (currentIndex === -1) {\n    return step > 0 ? 0 : lastIndex\n  }\n\n  const nextIndex = currentIndex + step\n\n  if (nextIndex < 0) {\n    return loop ? lastIndex : 0\n  }\n\n  if (nextIndex >= length) {\n    if (loop) return 0\n    return currentIndex > length ? length : currentIndex\n  }\n\n  return nextIndex\n}\n\n/**\n * Get's the previous index based on the current index.\n * Mostly used for keyboard navigation.\n *\n * @param index - the current index\n * @param count - the length or total count of items in the array\n * @param loop - whether we should circle back to the\n * first/last once `currentIndex` is at the start/end\n */\nexport function getPrevIndex(currentIndex: number, count: number, loop = true) {\n  return getNextIndex(currentIndex, count, -1, loop)\n}\n\n/**\n * Converts an array into smaller chunks or groups.\n *\n * @param array the array to chunk into group\n * @param size the length of each chunk\n */\nexport function chunk<T>(array: T[], size: number): T[][] {\n  return array.reduce((rows: T[][], currentValue: T, index: number) => {\n    if (index % size === 0) {\n      rows.push([currentValue])\n    } else {\n      rows[rows.length - 1].push(currentValue)\n    }\n    return rows\n  }, [] as T[][])\n}\n\n/**\n * Gets the next item based on a search string\n *\n * @param items array of items\n * @param searchString the search string\n * @param itemToString resolves an item to string\n * @param currentItem the current selected item\n */\nexport function getNextItemFromSearch<T>(\n  items: T[],\n  searchString: string,\n  itemToString: (item: T) => string,\n  currentItem: T,\n) {\n  if (searchString == null) {\n    return currentItem\n  }\n\n  // If current item doesn't exist, find the item that matches the search string\n  if (!currentItem) {\n    const foundItem = items.find((item) =>\n      itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()),\n    )\n    return foundItem\n  }\n\n  // Filter items for ones that match the search string (case insensitive)\n  const matchingItems = items.filter((item) =>\n    itemToString(item).toLowerCase().startsWith(searchString.toLowerCase()),\n  )\n\n  // If there's a match, let's get the next item to select\n  if (matchingItems.length > 0) {\n    let nextIndex: number\n\n    // If the currentItem is in the available items, we move to the next available option\n    if (matchingItems.includes(currentItem)) {\n      const currentIndex = matchingItems.indexOf(currentItem)\n      nextIndex = currentIndex + 1\n      if (nextIndex === matchingItems.length) {\n        nextIndex = 0\n      }\n      return matchingItems[nextIndex]\n    }\n    // Else, we pick the first item in the available items\n    nextIndex = items.indexOf(matchingItems[0])\n    return items[nextIndex]\n  }\n\n  // a decent fallback to the currentItem\n  return currentItem\n}\n\n/**\n * since breakpoints are defined as custom properties on an array, you may\n * `Object.keys(theme.breakpoints)` to retrieve both regular numeric indices\n * and custom breakpoints as string.\n *\n * This function returns true given a custom array property.\n */\nexport const isCustomBreakpoint = (maybeBreakpoint: string) =>\n  Number.isNaN(Number(maybeBreakpoint))\n"]},"metadata":{},"sourceType":"module"}