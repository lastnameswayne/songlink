{"ast":null,"code":"export { default as mergeWith } from \"lodash.mergewith\";\nexport { default as objectAssign } from \"object-assign\";\nexport function omit(object, keys) {\n  var result = {};\n  Object.keys(object).forEach(key => {\n    if (keys.includes(key)) return;\n    result[key] = object[key];\n  });\n  return result;\n}\nexport function pick(object, keys) {\n  var result = {};\n  keys.forEach(key => {\n    if (key in object) {\n      result[key] = object[key];\n    }\n  });\n  return result;\n}\nexport function split(object, keys) {\n  var picked = {};\n  var omitted = {};\n  Object.keys(object).forEach(key => {\n    if (keys.includes(key)) {\n      picked[key] = object[key];\n    } else {\n      omitted[key] = object[key];\n    }\n  });\n  return [picked, omitted];\n}\n/**\n * Get value from a deeply nested object using a string path.\n * Memoizes the value.\n * @param obj - the object\n * @param path - the string path\n * @param def  - the fallback value\n */\n\nexport function get(obj, path, fallback, index) {\n  var key = typeof path === \"string\" ? path.split(\".\") : [path];\n\n  for (index = 0; index < key.length; index += 1) {\n    if (!obj) {\n      break;\n    }\n\n    obj = obj[key[index]];\n  }\n\n  return obj === undefined ? fallback : obj;\n}\nexport var memoize = fn => {\n  var cache = new WeakMap();\n\n  var memoizedFn = (obj, path, fallback, index) => {\n    if (!cache.has(obj)) {\n      cache.set(obj, new Map());\n    }\n\n    var map = cache.get(obj);\n\n    if (map.has(path)) {\n      return map.get(path);\n    }\n\n    var value = fn(obj, path, fallback, index);\n    map.set(path, value);\n    return value;\n  };\n\n  return memoizedFn;\n};\nexport var memoizedGet = memoize(get);\n/**\n * Get value from deeply nested object, based on path\n * It returns the path value if not found in object\n *\n * @param path - the string path or value\n * @param scale - the string path or value\n */\n\nexport function getWithDefault(path, scale) {\n  return get(scale, path, path);\n}\n/**\n * Returns the items of an object that meet the condition specified in a callback function.\n *\n * @param object the object to loop through\n * @param fn The filter function\n */\n\nexport function objectFilter(object, fn) {\n  var result = {};\n  Object.keys(object).forEach(key => {\n    var value = object[key];\n    var shouldPass = fn(value, key, object);\n\n    if (shouldPass) {\n      result[key] = value;\n    }\n  });\n  return result;\n}\nexport var filterUndefined = object => objectFilter(object, val => val !== null && val !== undefined);\nexport var objectKeys = obj => Object.keys(obj);\n/**\n * Object.entries polyfill for Nodev10 compatibility\n */\n\nexport var fromEntries = entries => entries.reduce((carry, _ref) => {\n  var [key, value] = _ref;\n  carry[key] = value;\n  return carry;\n}, {});","map":{"version":3,"sources":["../../src/object.ts"],"names":["default","result","Object","key","keys","object","picked","omitted","path","index","obj","memoize","fn","cache","memoizedFn","map","value","memoizedGet","get","shouldPass","filterUndefined","objectFilter","val","objectKeys","fromEntries","entries","carry"],"mappings":"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","sourcesContent":["import type { Dict, Omit } from \"./types\"\n\nexport { default as mergeWith } from \"lodash.mergewith\"\nexport { default as objectAssign } from \"object-assign\"\n\nexport function omit<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    if (keys.includes(key as K)) return\n    result[key] = object[key]\n  })\n\n  return result as Omit<T, K>\n}\n\nexport function pick<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result = {} as { [P in K]: T[P] }\n\n  keys.forEach((key) => {\n    if (key in object) {\n      result[key] = object[key]\n    }\n  })\n\n  return result\n}\n\nexport function split<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const picked: Dict = {}\n  const omitted: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    if (keys.includes(key as T[K])) {\n      picked[key] = object[key]\n    } else {\n      omitted[key] = object[key]\n    }\n  })\n\n  return [picked, omitted] as [{ [P in K]: T[P] }, Omit<T, K>]\n}\n\n/**\n * Get value from a deeply nested object using a string path.\n * Memoizes the value.\n * @param obj - the object\n * @param path - the string path\n * @param def  - the fallback value\n */\nexport function get(\n  obj: object,\n  path: string | number,\n  fallback?: any,\n  index?: number,\n) {\n  const key = typeof path === \"string\" ? path.split(\".\") : [path]\n\n  for (index = 0; index < key.length; index += 1) {\n    if (!obj) {\n      break\n    }\n\n    obj = obj[key[index]]\n  }\n\n  return obj === undefined ? fallback : obj\n}\n\ntype Handler = (\n  obj: Readonly<object>,\n  path: string | number,\n  fallback?: any,\n  index?: number,\n) => any\n\nexport const memoize = (fn: Handler) => {\n  const cache = new WeakMap()\n\n  const memoizedFn: Handler = (\n    obj: object,\n    path: string | number,\n    fallback?: any,\n    index?: number,\n  ) => {\n    if (!cache.has(obj)) {\n      cache.set(obj, new Map())\n    }\n\n    const map = cache.get(obj)\n\n    if (map.has(path)) {\n      return map.get(path)\n    }\n\n    const value = fn(obj, path, fallback, index)\n\n    map.set(path, value)\n\n    return value\n  }\n\n  return memoizedFn\n}\n\nexport const memoizedGet = memoize(get)\n\n/**\n * Get value from deeply nested object, based on path\n * It returns the path value if not found in object\n *\n * @param path - the string path or value\n * @param scale - the string path or value\n */\nexport function getWithDefault(path: any, scale: any) {\n  return get(scale, path, path)\n}\n\ntype FilterFn<T> = (value: any, key: string, object: T) => boolean\n\n/**\n * Returns the items of an object that meet the condition specified in a callback function.\n *\n * @param object the object to loop through\n * @param fn The filter function\n */\nexport function objectFilter<T extends Dict>(object: T, fn: FilterFn<T>) {\n  const result: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    const value = object[key]\n    const shouldPass = fn(value, key, object)\n    if (shouldPass) {\n      result[key] = value\n    }\n  })\n\n  return result\n}\n\nexport const filterUndefined = (object: Dict) =>\n  objectFilter(object, (val) => val !== null && val !== undefined)\n\nexport const objectKeys = <T extends Dict>(obj: T) =>\n  (Object.keys(obj) as unknown) as (keyof T)[]\n\n/**\n * Object.entries polyfill for Nodev10 compatibility\n */\nexport const fromEntries = <T extends unknown>(entries: [string, any][]) =>\n  entries.reduce((carry, [key, value]) => {\n    carry[key] = value\n    return carry\n  }, {}) as T\n"]},"metadata":{},"sourceType":"module"}