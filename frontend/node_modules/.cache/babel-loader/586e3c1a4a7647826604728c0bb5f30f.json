{"ast":null,"code":"function _wrapRegExp(re, groups) {\n  _wrapRegExp = function _wrapRegExp(re, groups) {\n    return new BabelRegExp(re, undefined, groups);\n  };\n\n  var _RegExp = _wrapNativeSuper(RegExp);\n\n  var _super = RegExp.prototype;\n\n  var _groups = new WeakMap();\n\n  function BabelRegExp(re, flags, groups) {\n    var _this = _RegExp.call(this, re, flags);\n\n    _groups.set(_this, groups || _groups.get(re));\n\n    return _this;\n  }\n\n  _inherits(BabelRegExp, _RegExp);\n\n  BabelRegExp.prototype.exec = function (str) {\n    var result = _super.exec.call(this, str);\n\n    if (result) result.groups = buildGroups(result, this);\n    return result;\n  };\n\n  BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {\n    if (typeof substitution === \"string\") {\n      var groups = _groups.get(this);\n\n      return _super[Symbol.replace].call(this, str, substitution.replace(/\\$<([^>]+)>/g, function (_, name) {\n        return \"$\" + groups[name];\n      }));\n    } else if (typeof substitution === \"function\") {\n      var _this = this;\n\n      return _super[Symbol.replace].call(this, str, function () {\n        var args = [];\n        args.push.apply(args, arguments);\n\n        if (typeof args[args.length - 1] !== \"object\") {\n          args.push(buildGroups(args, _this));\n        }\n\n        return substitution.apply(this, args);\n      });\n    } else {\n      return _super[Symbol.replace].call(this, str, substitution);\n    }\n  };\n\n  function buildGroups(result, re) {\n    var g = _groups.get(re);\n\n    return Object.keys(g).reduce(function (groups, name) {\n      groups[name] = result[g[name]];\n      return groups;\n    }, Object.create(null));\n  }\n\n  return _wrapRegExp.apply(this, arguments);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nimport { memoizedGet as get, isObject } from \"@chakra-ui/utils\";\nvar directionMap = {\n  \"to-t\": \"to top\",\n  \"to-tr\": \"to top right\",\n  \"to-r\": \"to right\",\n  \"to-br\": \"to bottom right\",\n  \"to-b\": \"to bottom\",\n  \"to-bl\": \"to bottom left\",\n  \"to-l\": \"to left\",\n  \"to-tl\": \"to top left\"\n};\nvar valueSet = new Set(Object.values(directionMap));\nvar globals = [\"none\", \"-moz-initial\", \"inherit\", \"initial\", \"revert\", \"unset\"];\n\nvar trimSpace = str => str.trim();\n\nexport function parseGradient(value, theme) {\n  var _regex$exec$groups, _regex$exec;\n\n  if (value == null || globals.includes(value)) return value;\n\n  var regex = /*#__PURE__*/_wrapRegExp(/(^[\\x2DA-Za-z]+)\\(((.*?))\\)/g, {\n    type: 1,\n    values: 2\n  });\n\n  var {\n    type,\n    values\n  } = (_regex$exec$groups = (_regex$exec = regex.exec(value)) == null ? void 0 : _regex$exec.groups) != null ? _regex$exec$groups : {};\n  if (!type || !values) return value;\n\n  var _type = type.includes(\"-gradient\") ? type : type + \"-gradient\";\n\n  var [maybeDirection, ...stops] = values.split(\",\").map(trimSpace).filter(Boolean);\n  if ((stops == null ? void 0 : stops.length) === 0) return value;\n  var direction = maybeDirection in directionMap ? directionMap[maybeDirection] : maybeDirection;\n  stops.unshift(direction);\n\n  var _values = stops.map(stop => {\n    // if stop is valid shorthand direction, return it\n    if (valueSet.has(stop)) return stop; // color stop could be `red.200 20%` based on css gradient spec\n\n    var [_color, _stop] = stop.split(\" \"); // else, get and transform the color token or css value\n\n    var color = get(theme, \"colors.\" + _color, _color); // isObject(...) is an exception for users who use `red` instead of `red.100`\n\n    var result = isObject(color) ? stop : color;\n    return _stop ? [result, _stop].join(\" \") : result;\n  });\n\n  return _type + \"(\" + _values.join(\", \") + \")\";\n}\nexport var transformGradient = (value, _, theme) => parseGradient(value, theme != null ? theme : {});","map":{"version":3,"sources":["../../../src/utils/parse-gradient.ts"],"names":["memoizedGet","directionMap","valueSet","Object","globals","trimSpace","str","value","regex","values","_type","type","direction","maybeDirection","stops","_values","stop","color","get","result","isObject","_stop","transformGradient","parseGradient","theme"],"mappings":"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","sourcesContent":["import { Dict, memoizedGet as get, isObject } from \"@chakra-ui/utils\"\nimport { PropConfig } from \"../core\"\n\nconst directionMap = {\n  \"to-t\": \"to top\",\n  \"to-tr\": \"to top right\",\n  \"to-r\": \"to right\",\n  \"to-br\": \"to bottom right\",\n  \"to-b\": \"to bottom\",\n  \"to-bl\": \"to bottom left\",\n  \"to-l\": \"to left\",\n  \"to-tl\": \"to top left\",\n}\n\nconst valueSet = new Set(Object.values(directionMap))\n\nconst globals = [\n  \"none\",\n  \"-moz-initial\",\n  \"inherit\",\n  \"initial\",\n  \"revert\",\n  \"unset\",\n]\n\nconst trimSpace = (str: string) => str.trim()\n\nexport function parseGradient(value: string | null | undefined, theme: Dict) {\n  if (value == null || globals.includes(value)) return value\n\n  const regex = /(?<type>^[a-z-A-Z]+)\\((?<values>(.*?))\\)/g\n\n  const { type, values } = regex.exec(value)?.groups ?? {}\n\n  if (!type || !values) return value\n\n  const _type = type.includes(\"-gradient\") ? type : `${type}-gradient`\n\n  const [maybeDirection, ...stops] = values\n    .split(\",\")\n    .map(trimSpace)\n    .filter(Boolean)\n\n  if (stops?.length === 0) return value\n\n  const direction =\n    maybeDirection in directionMap\n      ? directionMap[maybeDirection]\n      : maybeDirection\n\n  stops.unshift(direction)\n\n  const _values = stops.map((stop) => {\n    // if stop is valid shorthand direction, return it\n    if (valueSet.has(stop)) return stop\n    // color stop could be `red.200 20%` based on css gradient spec\n    const [_color, _stop] = stop.split(\" \")\n    // else, get and transform the color token or css value\n    const color = get(theme, `colors.${_color}`, _color)\n    // isObject(...) is an exception for users who use `red` instead of `red.100`\n    const result = isObject(color) ? stop : color\n\n    return _stop ? [result, _stop].join(\" \") : result\n  })\n\n  return `${_type}(${_values.join(\", \")})`\n}\n\nexport const transformGradient: PropConfig[\"transform\"] = (value, _, theme) =>\n  parseGradient(value, theme ?? {})\n"]},"metadata":{},"sourceType":"module"}